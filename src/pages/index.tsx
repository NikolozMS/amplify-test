import React, { useMemo, useRef, useState } from "react";
import {
	QueryClient,
	dehydrate,
	useInfiniteQuery,
	useQuery,
} from "@tanstack/react-query";
import Head from "next/head";

import { BreadCrumb } from "@/components/BreadCrumbs";

import { getCount } from "@/services/getCount";
import { ParsedUrlQuery } from "querystring";

import { ProductHeader } from "@/components/Product/ProductHeader";
import { SearchTypes } from "@/types/searchTypes";

import { getProducts } from "@/services/getProducts";

import FiltersContainer from "@/components/filters/FiltersContainer";
import { useRouter } from "next/router";
import { Card } from "@/components/Product/Card";
import { ProductType } from "@/types/ProductType";
import { SearchChips } from "@/components/SearchChips";
import { objectToQueryString } from "@/utils/objectToQueryString";

const defaultQueries = {
	TypeID: 0,
	CurrencyID: 3,
};

// renderCountRef conditions

// 0 - from server
// 1 - from search (state)
// 2 - from browser route query

// when to look what

// first render - server
// shallow route - query
// other - seearch

const Home = ({ query }: { query: ParsedUrlQuery }) => {
	const { query: browserQuery, push, asPath } = useRouter();
	const [search, setSearch] = useState<SearchTypes>({
		...defaultQueries,
		...query,
		...browserQuery,
	});

	const renderCountRef = useRef(0);

	const searchAndQuery = useMemo(() => {
		// with server query
		if (renderCountRef.current === 0) {
			renderCountRef.current = 2;
			return {
				...defaultQueries,
				...search,
				...query,
			};
		}

		// with shallow route query
		if (renderCountRef.current === 1) {
			renderCountRef.current = 2;
			return {
				...search,
				...browserQuery,
			};
		}

		// search filters without any queries

		return search;
	}, [asPath, search]);

	const handleSearchSubmit = async () => {
		renderCountRef.current = 1;
		const queryString = objectToQueryString(search as ParsedUrlQuery);
		push(`/?${queryString}`, undefined, { shallow: true });
	};

	const {
		data: products,
		fetchNextPage,
		hasNextPage,
	} = useInfiniteQuery(
		[
			"prods",
			{ ...(renderCountRef.current === 0 ? query : {}), ...browserQuery },
		],
		(page) =>
			getProducts(
				{
					...(renderCountRef.current === 0 ? query : {}),
					...browserQuery,
				} as ParsedUrlQuery,
				page as { pageParam: number }
			),
		{
			getNextPageParam: ({ meta }) =>
				meta.current_page + 1 <= meta.last_page
					? meta.current_page + 1
					: undefined,
			getPreviousPageParam: ({ meta }) =>
				meta.current_page - 1 > 1 ? meta.current_page - 1 : undefined,

			staleTime: 1000 * 60 * 3,
			cacheTime: 1000 * 60 * 3,
			keepPreviousData: true,
		}
	);

	const { isLoading, data } = useQuery({
		queryKey: ["amount", searchAndQuery],
		queryFn: ({ signal }) => getCount(searchAndQuery as ParsedUrlQuery, signal),
		keepPreviousData: true,
	});

	const amountForProducts = useMemo(() => {
		return data?.count ?? 0;
	}, [asPath]);

	return (
		<>
			<Head>
				<meta name="description" content="Generated by create next app" />
				<meta name="title" content="MyAuto.ge" />
				<link rel="icon" href="/favicon.ico" />
				<title>MyAuto</title>
			</Head>

			<div className="flex flex-col items-start justify-start max-w-[104rem]  mx-auto md:mt-[3.2rem]">
				<BreadCrumb />

				<div className="flex gap-8 md:mt-8 w-full">
					<FiltersContainer
						isLoading={isLoading}
						search={search}
						query={query}
						setSearch={setSearch}
						foundAmount={data?.count ?? 0}
						handleSearchSubmit={handleSearchSubmit}
					/>

					<main className="flex flex-col flex-1">
						<ProductHeader
							foundAmount={amountForProducts}
							handleRenderRef={() => {
								renderCountRef.current = 1;
							}}
						/>
						<SearchChips />

						<section className="flex flex-col md:gap-[1rem] w-full  md:mt-[1.6rem]">
							{products?.pages.map((page, pageIndex) =>
								page?.items?.map((item: ProductType, itemsIndex) => {
									const isLast =
										pageIndex === products.pages.length - 1 &&
										itemsIndex === page.items.length - 1;

									return (
										<Card
											onLoadMoreClick={fetchNextPage}
											key={item.car_id}
											item={item}
											isLast={isLast}
											hasMore={hasNextPage}
										/>
									);
								})
							)}
						</section>
					</main>
				</div>
			</div>
		</>
	);
};

export const getServerSideProps = async ({
	query,
}: {
	query: ParsedUrlQuery;
}) => {
	const queryClient = new QueryClient();

	const search = {
		...defaultQueries,
		...query,
	};

	const queryKey = ["amount", search];

	await queryClient.prefetchQuery({
		queryKey,
		queryFn: () => getCount(search as any),
	});

	await queryClient.prefetchInfiniteQuery(
		["prods", search],
		() =>
			getProducts(search as any, {
				pageParam: 1,
			}),
		{
			initialData: {
				pageParams: [1],
				pages: [
					{
						items: [],
						meta: {
							current_page: 0,
							last_page: 1000,
							per_page: 30,
							total: 168000,
						},
					},
				],
			},
		}
	);

	return {
		props: {
			query: { ...search },
			dehydratedState: dehydrate(queryClient),
		},
	};
};

export default Home;
